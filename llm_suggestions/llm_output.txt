**===== FUNC_TEST_SUITE =====**  
# === APPEND NEW TRANSFORM FUNCTIONS BELOW ===  

  

def parse_salary_estimate(df):  
    """  
    Parse the ``Salary Estimate`` column which contains salary ranges in the form  
    ``$X-$Y`` (often with a trailing ``K`` or other characters) into two new numeric  
    columns: ``Salary_Min`` and ``Salary_Max``.  
    The original column is left unchanged.  
    """  
    import pandas as pd  
    import numpy as np  
    import re  

    df_out = df.copy()  
    change_log = []  

    # Remove dollar signs, commas and whitespace, then standardise “k” to thousand.  
    salary_clean = (  
        df_out["Salary Estimate"]  
        .astype(str)  
        .str.replace(r"[\$,]", "", regex=True)  
        .str.replace(r"\s+", "", regex=True)  
        .str.lower()  
        .str.replace(r"k", "000", regex=False)  
    )  

    # Extract all numeric groups (expecting two per row).  
    # ``extractall`` returns a MultiIndex; we unstack to get columns 0 and 1.  
    numbers = salary_clean.str.extractall(r"(\d+(?:\.\d+)?)")  
    numbers = numbers.unstack()  

    # Convert to numeric, coercing errors to NaN.  
    df_out["Salary_Min"] = pd.to_numeric(numbers[0], errors="coerce")  
    df_out["Salary_Max"] = pd.to_numeric(numbers[1], errors="coerce")  

    change_log.append(  
        "Parsed Salary Estimate into numeric Salary_Min and Salary_Max columns."  
    )  

    return df_out, change_log  



def clean_rating(df):  
    """  
    Replace negative rating values (e.g., ``-1``) which are used as missing‑data indicators  
    with ``NaN``. Any rating below ``0`` is also treated as missing.  
    """  
    import numpy as np  

    df_out = df.copy()  
    change_log = []  

    # Identify negative values and replace them with NaN.  
    df_out["Rating"] = df_out["Rating"].apply(  
        lambda x: np.nan if pd.isna(x) or (isinstance(x, (int, float)) and x < 0) else x  
    )  

    change_log.append("Replaced negative Rating values with NaN.")  

    return df_out, change_log  



def clean_founded(df):  
    """  
    Convert negative ``Founded`` years (commonly ``-1``) to ``NaN`` because they represent  
    missing information.  
    """  
    import numpy as np  

    df_out = df.copy()  
    change_log = []  

    df_out["Founded"] = df_out["Founded"].apply(  
        lambda x: np.nan if pd.isna(x) or (isinstance(x, (int, float)) and x < 0) else x  
    )  

    change_log.append("Replaced negative Founded values with NaN.")  

    return df_out, change_log  



def clean_job_description_newlines(df):  
    """  
    Remove newline characters from the ``Job Description`` column, replacing them with a  
    single space so the text becomes a single‑line string. Leading/trailing whitespace is  
    stripped.  
    """  
    df_out = df.copy()  
    change_log = []  

    df_out["Job Description"] = (  
        df_out["Job Description"]  
        .astype(str)  
        .str.replace(r"[\r\n]+", " ", regex=True)  
        .str.strip()  
    )  

    change_log.append("Replaced newlines in Job Description with spaces.")  

    return df_out, change_log  



def clean_company_name_newlines(df):  
    """  
    Remove newline characters from the ``Company Name`` column, replacing them with a  
    single space and stripping surrounding whitespace.  
    """  
    df_out = df.copy()  
    change_log = []  

    df_out["Company Name"] = (  
        df_out["Company Name"]  
        .astype(str)  
        .str.replace(r"[\r\n]+", " ", regex=True)  
        .str.strip()  
    )  

    change_log.append("Replaced newlines in Company Name with spaces.")  

    return df_out, change_log  



def split_competitors_to_list(df):  
    """  
    Convert the ``Competitors`` column, which contains comma‑separated competitor names,  
    into a list of strings. Empty or missing entries become empty lists.  
    """  
    df_out = df.copy()  
    change_log = []  

    df_out["Competitors_List"] = (  
        df_out["Competitors"]  
        .astype(str)  
        .apply(lambda x: [] if x.strip() in {"nan", "-1"} else [item.strip() for item in x.split(",")])  
    )  

    change_log.append("Created Competitors_List column with list of competitors.")  

    return df_out, change_log  



**===== REASONING =====**  
# Use this file to store the function name for each piece of generated code,  
# and the reasoning for why each piece of transformative code was written/produced the way it was  

# === APPEND REASONING BELOW ===  

parse_salary_estimate:  
- The dataset’s ``Salary Estimate`` column is 100 % in a range format (e.g., “$50K-$70K”).  
- Direct numeric analysis is impossible without separating the minimum and maximum values.  
- This function creates two new numeric columns ``Salary_Min`` and ``Salary_Max`` by cleaning the string, handling optional “K” suffixes, and extracting the two numbers.  
- Keeping the original column untouched preserves raw information for auditability.  

clean_rating:  
- ``Rating`` contains 50 negative values (minimum –1).  
- Negative values are identified as missing‑data indicators.  
- Converting them to ``NaN`` enables proper statistical calculations and avoids misleading low ratings.  

clean_founded:  
- ``Founded`` has 118 negative entries (minimum –1), which similarly act as missing indicators.  
- Replacing negatives with ``NaN`` standardises the column for downstream temporal analyses.  

clean_job_description_newlines:  
- ``Job Description`` shows 94 % of rows with embedded newlines, indicating multi‑line text that hampers tokenisation and display.  
- Replacing newlines with spaces creates a single‑line description while preserving the textual content.  

clean_company_name_newlines:  
- ``Company Name`` also contains newlines in >90 % of rows, likely due to data entry errors.  
- Normalising the column by removing newlines yields clean company identifiers.  

split_competitors_to_list:  
- ``Competitors`` is a high‑cardinality column containing comma‑separated lists of competitor names.  
- Converting this string into a list column (``Competitors_List``) makes it easier to analyse relationships, count competitors, or explode the data if needed.  
- Missing indicators (“-1”) are turned into empty lists to avoid errors in later processing.  