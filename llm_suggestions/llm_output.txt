===== FUNC_TEST_SUITE =====
# Instructions

# Identity

You are an expert python developer and a data analysis expert that helps generate suggested transformation code for a supplied pandas dataframe that is:
- Pandas-native
- Non-destructive by default
- Human-readable and reviewable

When analyzing datasets:
1. First use pandas to inspect the actual data (df.head(), df.dtypes, df.describe())
2. Check for ALL data quality issues (missing values, formatting, embedded data, ranges)
3. Test your suggested transformations before proposing them
4. Provide working, executable code with error handling

The contents of func_test_suite.txt are the SINGLE authoritative source of truth.
All other instructions are subordinate to it.
If any instruction conflicts with func_test_suite.txt, func_test_suite.txt MUST be followed.

#This txt serves as the template that will store the suggested code: 
# DO NOT MODIFY THE TEXT IN THIS DOCUMENT OTHER THAN TO APPEND CODE TO IT
#This test suite should have a logical flow and spaces + comments/docstrings to explain each piece of code

#Rules:
#You MUST NOT modify, delete, or reorder any existing text.
#You MAY ONLY append new content to the end of the document.
#All appended code MUST be placed after the line:
## === APPEND NEW TRANSFORM FUNCTIONS BELOW ===
#Leave at least one blank line before any appended content.
#Preserve all existing comments and spacing exactly as-is.

#Do NOT:
#- Refactor existing code
#- Rename variables defined earlier
#- Inline transformations into existing functions
#- Remove comments or docstrings
#- Assume execution order

#Formatting requirements:
#Leave two blank lines between each appended function
#Leave one blank line between comments and code
#Do not remove existing blank lines

#Appended content MUST consist only of standalone function definitions.
#Each appended function MUST include a docstring describing the transformation.
#All appended functions MUST operate on a copy of a DataFrame and MUST NOT modify inputs in-place.
#Before responding, verify that no text above the append marker has been modified.

# === APPEND NEW TRANSFORM FUNCTIONS BELOW ===


def clean_company_name(df):
    """
    Standardize the 'Company Name' column:
    - Strip leading/trailing whitespace (if any)
    - Convert to title case for consistent capitalization
    Returns a new DataFrame and a change log.
    """
    df_out = df.copy()
    change_log = []

    try:
        # Strip whitespace and apply title case
        df_out["Company Name"] = df_out["Company Name"].str.strip().str.title()
        change_log.append("Standardized 'Company Name' to title case and stripped whitespace.")
    except Exception as e:
        change_log.append(f"Failed to clean 'Company Name': {e}")

    return df_out, change_log


def parse_salary_estimate(df):
    """
    Parse the free‑text 'Salary Estimate' column into three numeric columns:
    - Salary Min: lower bound of the salary range
    - Salary Max: upper bound of the salary range
    - Salary Avg: average of the two bounds
    Non‑numeric characters (currency symbols, commas, 'K', etc.) are removed.
    Returns a new DataFrame and a change log.
    """
    import re
    import numpy as np
    df_out = df.copy()
    change_log = []

    def extract_numbers(s):
        # Find all numeric groups (including those with commas)
        nums = re.findall(r"[\d,.]+", str(s))
        # Clean commas and convert to float
        cleaned = [float(n.replace(",", "")) for n in nums if n.replace(",", "").replace(".", "", 1).isdigit()]
        return cleaned

    try:
        mins = []
        maxs = []
        avgs = []

        for val in df_out["Salary Estimate"]:
            numbers = extract_numbers(val)
            if len(numbers) >= 2:
                low, high = numbers[0], numbers[1]
            elif len(numbers) == 1:
                low = high = numbers[0]
            else:
                low = high = np.nan
            mins.append(low)
            maxs.append(high)
            avgs.append(np.mean([low, high]) if not (np.isnan(low) or np.isnan(high)) else np.nan)

        df_out["Salary Min"] = mins
        df_out["Salary Max"] = maxs
        df_out["Salary Avg"] = avgs

        change_log.append("Extracted numeric salary bounds into 'Salary Min', 'Salary Max', and 'Salary Avg'.")
    except Exception as e:
        change_log.append(f"Failed to parse 'Salary Estimate': {e}")

    return df_out, change_log


def clean_founded_year(df):
    """
    Validate and clean the 'Founded' year column:
    - Convert to numeric (coerce errors to NaN)
    - Replace years outside the realistic range [1800, current year] with NaN
    Returns a new DataFrame and a change log.
    """
    import numpy as np
    import pandas as pd
    from datetime import datetime

    df_out = df.copy()
    change_log = []

    try:
        # Ensure numeric type
        df_out["Founded"] = pd.to_numeric(df_out["Founded"], errors="coerce")

        current_year = datetime.now().year
        mask_invalid = (df_out["Founded"] < 1800) | (df_out["Founded"] > current_year)

        num_invalid = mask_invalid.sum()
        df_out.loc[mask_invalid, "Founded"] = np.nan

        change_log.append(
            f"Cleaned 'Founded' column: set {num_invalid} out‑of‑range values to NaN."
        )
    except Exception as e:
        change_log.append(f"Failed to clean 'Founded' column: {e}")

    return df_out, change_log


===== REASONING =====
#Use this file to store the function name for each piece of generated code,
#and the reasoning for why each piece of transformative code was written/produced the way it was

# === APPEND REASONING BELOW ===

clean_company_name
- The dataset flagged the 'Company Name' column as having mixed case. Standardizing to title case improves consistency for downstream grouping or merging operations. Stripping whitespace (even though none were reported) is a safe defensive step.

parse_salary_estimate
- 'Salary Estimate' is a free‑text field containing currency symbols, ranges, and parentheses. Converting it into explicit numeric columns ('Salary Min', 'Salary Max', 'Salary Avg') enables quantitative analysis (e.g., salary distribution, correlation with rating). The function uses a regex to pull numeric tokens, handles missing or single‑value cases, and logs any parsing failures.

clean_founded_year
- The 'Founded' column contains years, but the numeric summary shows a high outlier ratio and skewness, indicating implausible values (e.g., future years or very early dates). This function coerces the column to numeric, then replaces any year outside the realistic window of 1800 to the current year with NaN, providing a clean, analyzable field. The number of corrected entries is recorded in the change log.